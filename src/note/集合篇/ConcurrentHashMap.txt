添加元素
（1）如果桶数组未初始化，则初始化；
（2）如果待插入的元素所在的桶为空，则尝试把此元素直接插入到桶的第一个位置；
（3）如果正在扩容，则当前线程一起加入到扩容的过程中；
（4）如果待插入的元素所在的桶不为空且不在迁移元素，则锁住这个桶（分段锁）；
（5）如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者插入元素；
（6）如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；
（7）如果元素存在，则返回旧值；
（8）如果元素不存在，整个Map的元素个数加1，并检查是否需要扩容；

初始化桶数组:第一次放元素时，初始化桶数组。
（1）使用CAS锁控制只有一个线程初始化桶数组；
（2）sizeCtl在初始化后存储的是扩容门槛；
（3）扩容门槛写死的是桶数组大小的0.75倍，桶数组大小即map的容量，也就是最多存储多少个元素。

判断是否需要扩容:每次添加元素后，元素数量加1，并判断是否达到扩容门槛，达到了则进行扩容或协助扩容。
（1）元素个数的存储方式类似于LongAdder类，存储在不同的段上，减少不同线程同时更新size时的冲突；
（2）计算元素个数时把这些段的值及baseCount相加算出总的元素个数；
（3）正常情况下sizeCtl存储着扩容门槛，扩容门槛为容量的0.75倍；
（4）扩容时sizeCtl高位存储扩容邮戳(resizeStamp)，低位存储扩容线程数加1（1+nThreads）；
（5）其它线程添加元素后如果发现存在扩容，也会加入的扩容行列中来；

协助扩容（迁移元素）:线程添加元素时发现正在扩容且当前元素所在的桶元素已经迁移完成了，则协助迁移其它桶的元素。

迁移元素：扩容时容量变为两倍，并把部分元素迁移到其他桶中
（1）新桶数组大小是旧桶数组的两倍；
（2）迁移元素先从靠后的桶开始；
（3）迁移完成的桶在里面放置一ForwardingNode类型的元素，标记该桶迁移完成；
（4）迁移时根据hash&n是否等于0把桶中元素分化成两个链表或树；
（5）低位链表（树）存储在原来的位置；
（6）高们链表（树）存储在原来的位置加n的位置；
（7）迁移元素时会锁住当前桶，也是分段锁的思想；

删除元素：删除元素跟添加元素一样，都是先找到元素所在的桶，然后采用分段锁的思想锁住整个桶，再进行操作
（1）计算hash；
（2）如果所在的桶不存在，表示没有找到目标元素，返回；
（3）如果正在扩容，则协助扩容完成后再进行删除操作；
（4）如果是以链表形式存储的，则遍历整个链表查找元素，找到之后再删除；
（5）如果是以树形式存储的，则遍历树查找元素，找到之后再删除；
（6）如果是以树形式存储的，删除元素之后树较小，则退化成链表；
（7）如果确实删除了元素，则整个map元素个数减1，并返回旧值；
（8）如果没有删除元素，则返回null；

获取元素:获取元素，根据目标key所在桶的第一个元素的不同采用不同的方式获取元素，关键点在于find()方法的重写
（1）hash到元素所在的桶；
（2）如果桶中第一个元素就是该找的元素，直接返回；
（3）如果是树或者正在迁移元素，则调用各自Node子类的find()方法寻找元素；
（4）如果是链表，遍历整个链表寻找元素；
（5）获取元素没有加锁；

获取元素个数:
（1）元素的个数依据不同的线程存在在不同的段里；（见addCounter()分析）
（2）计算CounterCell所有段及baseCount的数量之和；
（3）获取元素个数没有加锁；

总结：
（1）ConcurrentHashMap是HashMap的线程安全版本；
（2）ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素；
（3）ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多；
（4）ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等；
（5）ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制；
（6）sizeCtl = -1，表示正在进行初始化；
（7）sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；
（8）sizeCtl > 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛；
（9）sizeCtl = (resizeStamp << 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1；
（10）更新操作时如果正在进行扩容，当前线程协助扩容；
（11）更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想；
（12）整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键；
（13）迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕；
（14）元素个数的存储也是采用的分段思想，类似于LongAdder的实现；
（15）元素个数的更新会把不同的线程hash到不同的段上，减少资源争用；
（16）元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）；
（17）获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的；
（18）查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的；
（19）ConcurrentHashMap中不能存储key或value为null的元素；

