add(E e)方法
（1）加锁；
（2）获取元素数组；
（3）新建一个数组，大小为原数组长度加1，并把原数组元素拷贝到新数组；
（4）把新添加的元素放到新数组的末尾；
（5）把新数组赋值给当前对象的array属性，覆盖原数组；
（6）解锁；

add(int index, E element)方法
（1）加锁；
（2）检查索引是否合法，如果不合法抛出IndexOutOfBoundsException异常，注意这里index等于len也是合法的；
（3）如果索引等于数组长度（也就是数组最后一位再加1），那就拷贝一个len+1的数组；
（4）如果索引不等于数组长度，那就新建一个len+1的数组，并按索引位置分成两部分，索引之前（不包含）的部分拷贝到新数组索引之前（不包含）的部分，索引之后（包含）的位置拷贝到新数组索引之后（不包含）的位置，索引所在位置留空；
（5）把索引位置赋值为待添加的元素；
（6）把新数组赋值给当前对象的array属性，覆盖原数组；
（7）解锁；

addIfAbsent(E e)方法:添加一个元素如果这个元素不存在于集合中。
（1）检查这个元素是否存在于数组快照中；
（2）如果存在直接返回false，如果不存在调用addIfAbsent(E e, Object[] snapshot)处理;
（3）加锁；
（4）如果当前数组不等于传入的快照，说明有修改，检查待添加的元素是否存在于当前数组中，如果存在直接返回false;
（5）拷贝一个新数组，长度等于原数组长度加1，并把原数组元素拷贝到新数组中；
（6）把新元素添加到数组最后一位；
（7）把新数组赋值给当前对象的array属性，覆盖原数组；
（8）解锁；

remove(int index)方法
（1）加锁；
（2）获取指定索引位置元素的旧值；
（3）如果移除的是最后一位元素，则把原数组的前len-1个元素拷贝到新数组中，并把新数组赋值给当前对象的数组属性；
（4）如果移除的不是最后一位元素，则新建一个len-1长度的数组，并把原数组除了指定索引位置的元素全部拷贝到新数组中，并把新数组赋值给当前对象的数组属性；
（5）解锁并返回旧值；

总结：
（1）CopyOnWriteArrayList使用ReentrantLock重入锁加锁，保证线程安全；
（2）CopyOnWriteArrayList的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是O(n)，性能比较低下；
（3）CopyOnWriteArrayList的读操作支持随机访问，时间复杂度为O(1)；
（4）CopyOnWriteArrayList采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合；
（5）CopyOnWriteArrayList只保证最终一致性，不保证实时一致性；

每次拷贝时都是拷贝一个正好可以存放目标个数元素的数组，故数组的长度就是集合的大小，不需要size进行统计