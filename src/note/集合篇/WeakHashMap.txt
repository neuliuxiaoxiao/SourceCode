put(K key, V value)方法
（1）计算hash；
这里与HashMap有所不同，HashMap中如果key为空直接返回0，这里是用空对象来计算的。
另外打散方式也不同，HashMap只用了一次异或，这里用了四次，HashMap给出的解释是一次够了，而且就算冲突了也会转换成红黑树，对效率没什么影响。
（2）计算在哪个桶中；
（3）遍历桶对应的链表；
（4）如果找到元素就用新值替换旧值，并返回旧值；
（5）如果没找到就在链表头部插入新元素；
HashMap就插入到链表尾部。
（6）如果元素数量达到了扩容门槛，就把容量扩大到2倍大小；
HashMap中是大于threshold才扩容，这里等于threshold就开始扩容了。

resize(int newCapacity)方法
（1）判断旧容量是否达到最大容量；
（2）新建新桶并把元素全部转移到新桶中；
（3）如果转移后元素个数不到扩容门槛的一半，则把元素再转移回旧桶，继续使用旧桶，说明不需要扩容；
（4）否则使用新桶，并计算新的扩容门槛；
（5）转移元素的过程中会把key为null的元素清除掉，所以size会变小；

get(Object key)方法
（1）计算hash值；
（2）遍历所在桶对应的链表；
（3）如果找到了就返回元素的value值；
（4）如果没找到就返回空；

remove(Object key)方法
（1）计算hash；
（2）找到所在的桶；
（3）遍历桶对应的链表；
（4）如果找到了就删除该节点，并返回该节点的value值；
（5）如果没找到就返回null；

expungeStaleEntries()方法
（1）当key失效的时候gc会自动把对应的Entry添加到这个引用队列中；
（2）所有对map的操作都会直接或间接地调用到这个方法先移除失效的Entry，比如getTable()、size()、resize()；
（3）这个方法的目的就是遍历引用队列，并把其中保存的Entry从map中移除掉，具体的过程请看类注释；
（4）从这里可以看到移除Entry的同时把value也一并置为null帮助gc清理元素，防御性编程。
