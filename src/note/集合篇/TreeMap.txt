红黑树特性
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

get(Object key)方法
（1）从root遍历整个树；
（2）如果待查找的key比当前遍历的key小，则在其左子树中查找；
（3）如果待查找的key比当前遍历的key大，则在其右子树中查找；
（4）如果待查找的key与当前遍历的key相等，则找到了该元素，直接返回；
（5）从这里可以看出是否有comparator分化成了两个方法，但是内部逻辑一模一样

左旋：参考img/left-rotation.jpg
（1）将 y的左节点 设为 x的右节点，即将 β 设为 x的右节点；
（2）将 x 设为 y的左节点的父节点，即将 β的父节点 设为 x；
（3）将 x的父节点 设为 y的父节点；
（4）如果 x的父节点 为空节点，则将y设置为根节点；如果x是它父节点的左（右）节点，则将y设置为x父节点的左（右）节点；
（5）将 x 设为 y的左节点；
（6）将 x的父节点 设为 y；

右旋：参考img/right-rotation.jpg
（1）将 x的右节点 设为 y的左节点，即 将 β 设为 y的左节点；
（2）将 y 设为 x的右节点的父节点，即 将 β的父节点 设为 y；
（3）将 y的父节点 设为 x的父节点；
（4）如果 y的父节点 是 空节点，则将x设为根节点；如果y是它父节点的左（右）节点，则将x设为y的父节点的左（右）节点；
（5）将 y 设为 x的右节点；
（6）将 y的父节点 设为 x；

插入元素：如果元素在树中存在，则替换value；如果元素不存在，则插入到对应的位置，再平衡树。

插入再平衡
插入的元素默认都是红色，因为插入红色元素只违背了第4条特性，那么我们只要根据这个特性来平衡就容易多了。
根据不同的情况有以下几种处理方式：
    1插入的元素如果是根节点，则直接涂成黑色即可，不用平衡；
    2插入的元素的父节点如果为黑色，不需要平衡；
    3插入的元素的父节点如果为红色，则违背了特性4，需要平衡，平衡时又分成下面三种情况：
（如果父节点是祖父节点的左节点）
1）父节点为红色，叔叔节点也为红色
    （1）将父节点设为黑色；
    （2）将叔叔节点设为黑色；
    （3）将祖父节点设为红色；
    （4）将祖父节点设为新的当前节点，进入下一次循环判断；
2）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的右节点
    （1）将父节点作为新的当前节点；
    （2）以新当节点为支点进行左旋，进入情况3）；
3）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的左节点
    （1）将父节点设为黑色；
    （2）将祖父节点设为红色；
    （3）以祖父节点为支点进行右旋，进入下一次循环判断；
（如果父节点是祖父节点的右节点，则正好与上面反过来）
1）父节点为红色，叔叔节点也为红色
    （1）将父节点设为黑色；
    （2）将叔叔节点设为黑色；
    （3）将祖父节点设为红色；
    （4）将祖父节点设为新的当前节点，进入下一次循环判断；
2）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的左节点
    （1）将父节点作为新的当前节点；
    （2）以新当节点为支点进行右旋；
3）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的右节点
    （1）将父节点设为黑色；
    （2）将祖父节点设为红色；
    （3）以祖父节点为支点进行左旋，进入下一次循环判断；

删除元素
（1）如果删除的位置有两个叶子节点，则从其右子树中取最小的元素放到删除的位置，然后把删除位置移到替代元素的位置，进入下一步。
（2）如果删除的位置只有一个叶子节点（有可能是经过第一步转换后的删除位置），则把那个叶子节点作为替代元素，放到删除的位置，然后把这个叶子节点删除。
（3）如果删除的位置没有叶子节点，则直接把这个删除位置的元素删除即可。
（4）针对红黑树，如果删除位置是黑色节点，还需要做再平衡。
（5）如果有替代元素，则以替代元素作为当前节点进入再平衡。
（6）如果没有替代元素，则以删除的位置的元素作为当前节点进入再平衡，平衡之后再删除这个节点

删除再平衡
真正删除的肯定是黑色节点才会进入到再平衡阶段。
因为删除的是黑色节点，导致整颗树不平衡了，所以这里我们假设把删除的黑色赋予当前节点，这样当前节点除了它自已的颜色还多了一个黑色，那么：
    （1）如果当前节点是根节点，则直接涂黑即可，不需要再平衡；
    （2）如果当前节点是红+黑节点，则直接涂黑即可，不需要平衡；
    （3）如果当前节点是黑+黑节点，则我们只要通过旋转把这个多出来的黑色不断的向上传递到一个红色节点即可，这又可能会出现以下四种情况：
（假设当前节点为父节点的左子节点）
1）x是黑+黑节点，x的兄弟是红节点
    （1）将兄弟节点设为黑色；
    （2）将父节点设为红色；
    （3）以父节点为支点进行左旋；
    （4）重新设置x的兄弟节点，进入下一步；
2）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的两个子节点都是黑色
    （1）将兄弟节点设置为红色；
    （2）将x的父节点作为新的当前节点，进入下一次循环；
3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的右子节点为黑色，左子节点为红色
    （1）将兄弟节点的左子节点设为黑色；
    （2）将兄弟节点设为红色；
    （3）以兄弟节点为支点进行右旋；
    （4）重新设置x的兄弟节点，进入下一步；
3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的右子节点为红色，左子节点任意颜色
    （1）将兄弟节点的颜色设为父节点的颜色；
    （2）将父节点设为黑色；
    （3）将兄弟节点的右子节点设为黑色；
    （4）以父节点为支点进行左旋；
    （5）将root作为新的当前节点（退出循环）；
（假设当前节点为父节点的右子节点，正好反过来）
1）x是黑+黑节点，x的兄弟是红节点
    （1）将兄弟节点设为黑色；
    （2）将父节点设为红色；
    （3）以父节点为支点进行右旋；
    （4）重新设置x的兄弟节点，进入下一步；
2）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的两个子节点都是黑色
    （1）将兄弟节点设置为红色；
    （2）将x的父节点作为新的当前节点，进入下一次循环；
3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的左子节点为黑色，右子节点为红色
    （1）将兄弟节点的右子节点设为黑色；
    （2）将兄弟节点设为红色；
    （3）以兄弟节点为支点进行左旋；
    （4）重新设置x的兄弟节点，进入下一步；
3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的左子节点为红色，右子节点任意颜色
    （1）将兄弟节点的颜色设为父节点的颜色；
    （2）将父节点设为黑色；
    （3）将兄弟节点的左子节点设为黑色；
    （4）以父节点为支点进行右旋；
    （5）将root作为新的当前节点（退出循环）；

   总结：
      （1）每个节点或者是黑色，或者是红色。
      （2）根节点是黑色。
      （3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）
      （4）如果一个节点是红色的，则它的子节点必须是黑色的。
      （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
      除了上述这些标准的红黑树的特性，你还能讲出来哪些TreeMap的特性呢？
      （1）TreeMap的存储结构只有一颗红黑树；
      （2）TreeMap中的元素是有序的，按key的顺序排列；
      （3）TreeMap比HashMap要慢一些，因为HashMap前面还做了一层桶，寻找元素要快很多；
      （4）TreeMap没有扩容的概念；
      （5）TreeMap的遍历不是采用传统的递归式遍历；
      （6）TreeMap可以按范围查找元素，查找最近的元素；